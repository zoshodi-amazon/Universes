# RL Module Architecture
# Type-theoretic capability graph: Options (types) → Bindings (terms) → Effects (runtime)
#
# Stack: Nix (types + packaging) → Nushell (glue + interop) → CLIs (effects)
# Arch.d2 = morphism diagram. Trace any capability from type → term → effect.

direction: right

# =============================================================================
# LAYER 1: OPTIONS (Product Types — the capability schema)
# =============================================================================
# Every option is a type declaration. Nushell scripts receive these as typed config.
# Nix module options = single source of truth for ALL typing.

Options: {
  label: "Options (Types)"
  style.fill: "#e1f5fe"

  Env: {
    label: "Env : EnvSpec"
    shape: class
    envId: "str = CartPole-v1"
    nEnvs: "int = 4"
    seed: "int? = null"
  }

  Agent: {
    label: "Agent : AgentSpec"
    shape: class
    algorithm: "enum [ppo a2c dqn sac td3]"
    policyType: "enum [MlpPolicy CnnPolicy]"
    netArch: "list int = [64 64]"
  }

  Train: {
    label: "Train : TrainSpec"
    shape: class
    totalTimesteps: "int = 100000"
    learningRate: "str = 3e-4"
    batchSize: "int = 64"
    gamma: "str = 0.99"
  }

  Eval: {
    label: "Eval : EvalSpec"
    shape: class
    episodes: "int = 10"
    deterministic: "bool = true"
  }

  Infer: {
    label: "Infer : InferSpec"
    shape: class
    modelPath: "str = ./models/best.zip"
    device: "enum [auto cpu cuda mps]"
  }

  Store: {
    label: "Store : StoreSpec"
    shape: class
    backend: "enum [local mlflow wandb]"
    modelDir: "str = ./models"
    checkpointFreq: "int = 10000"
    trackingUri: "str"
    experimentName: "str"
  }

  Obs: {
    label: "Obs : ObsSpec"
    shape: class
    dbPath: "str = ./rl.db"
    logDir: "str = ./logs"
    logLevel: "enum [debug info warn error]"
  }
}

# =============================================================================
# LAYER 2: BINDINGS (Morphisms — nushell scripts interpreting Options)
# =============================================================================
# Each binding is a morphism: Options → Effect
# Nushell = glue layer. Receives typed config from Nix, calls CLIs.
# All scripts strongly typed off Nix module Options.

Bindings: {
  label: "Bindings (Terms)"
  style.fill: "#fff3e0"

  train_nu: {
    label: "Train/Scripts/default.nu"
    shape: page
    signature: "TrainSpec → Effect"
    impl: |md
      let cfg = (open $config_path)
      ^rl train
        --env $cfg.env.envId
        --algo $cfg.agent.algorithm
        --timesteps $cfg.train.totalTimesteps
        --lr $cfg.train.learningRate
        --db $cfg.obs.dbPath
    |
  }

  eval_nu: {
    label: "Eval/Scripts/default.nu"
    shape: page
    signature: "EvalSpec → Effect"
    impl: |md
      let cfg = (open $config_path)
      ^rl eval
        --model (db_best_model $cfg.obs.dbPath)
        --episodes $cfg.eval.episodes
    |
  }

  infer_nu: {
    label: "Infer/Scripts/default.nu"
    shape: page
    signature: "InferSpec → Effect"
    impl: |md
      let cfg = (open $config_path)
      ^rl infer
        --model (db_best_model $cfg.obs.dbPath)
        --device $cfg.infer.device
    |
  }

  db_nu: {
    label: "Obs/Scripts/default.nu"
    shape: page
    signature: "ObsSpec → Table"
    impl: |md
      # Native nushell SQLite interop
      open $cfg.obs.dbPath
        | query db "SELECT * FROM runs
           ORDER BY mean_reward DESC"
    |
  }

  store_nu: {
    label: "Store/Bindings/default.nix"
    shape: page
    signature: "StoreSpec → ENV"
    impl: |md
      backend=mlflow → MLFLOW_TRACKING_URI
      backend=wandb  → WANDB_BASE_URL
      backend=local  → RL_STORE_MODEL_DIR
    |
  }
}

# =============================================================================
# LAYER 3: DERIVATIONS (Frozen CLIs — language-specific logic)
# =============================================================================
# Python/sb3/gymnasium frozen into a single Nix derivation.
# Exposes `rl` CLI with subcommands. Nushell never touches Python.

Drv: {
  label: "Drv/ (Frozen CLIs)"
  style.fill: "#f3e5f5"

  rl: {
    label: "rl (Python CLI)"
    shape: package
    subcommands: |md
      rl train  — sb3 model.learn()
      rl eval   — sb3 evaluate_policy()
      rl infer  — sb3 model.predict()
    |
    deps: "sb3, gymnasium, gym-anytrading"
  }
}

# =============================================================================
# LAYER 4: DATA (Effects — runtime + persistent state)
# =============================================================================
# Obs = looking glass into two scopes:
#   Runtime: logs (tail -f), stdout
#   Persistent: SQLite db (nushell native query)

Data: {
  label: "Data (Effects)"
  style.fill: "#e8f5e9"

  sqlite: {
    label: "SQLite (rl.db)"
    shape: cylinder
    schema: |md
      runs: id, env_id, algorithm,
        timesteps, mean_reward,
        std_reward, model_path,
        hyperparams, validated,
        timestamp
    |
  }

  logs: {
    label: "Logs (./logs/)"
    shape: document
    content: "training stdout, checkpoints, errors"
  }

  models: {
    label: "Models (./models/)"
    shape: document
    content: "*.zip model checkpoints"
  }
}

# =============================================================================
# LAYER 5: INSTANCES (Nix targets — what gets exported)
# =============================================================================

Instances: {
  label: "Instances (Exports)"
  style.fill: "#e8f5e9"

  devShell: {
    label: "perSystem.devShells.rl"
    shape: hexagon
    contains: "rl CLI, nushell, sqlite, ENV vars"
  }

  cmds: {
    label: "perSystem.packages.*"
    shape: hexagon
    exports: |md
      rl-train  (nushell → rl train)
      rl-eval   (nushell → rl eval)
      rl-infer  (nushell → rl infer)
      rl-db     (nushell → sqlite query)
    |
  }
}

# =============================================================================
# LAYER 6: TMUX PRESET (IDE layout — panes map to capabilities)
# =============================================================================

IDE: {
  label: "Tmux Preset: lab RL"
  style.fill: "#fce4ec"

  layout: |md
    +------------------+-------------+
    | Shell (just/nu)  | Logs (tail) |
    |  rl-train        |  ./logs/    |
    |  rl-eval         |             |
    +------------------+-------------+
    | DB (nu query)    | Metrics     |
    |  open rl.db      |  rl-db      |
    |  | query db ...  |  | table    |
    +------------------+-------------+
  |
}

# =============================================================================
# MORPHISMS (Type-theoretic flow)
# =============================================================================

# Options → Nushell scripts (config injection)
Options.Env -> Bindings.train_nu: "config"
Options.Agent -> Bindings.train_nu: "config"
Options.Train -> Bindings.train_nu: "config"
Options.Eval -> Bindings.eval_nu: "config"
Options.Infer -> Bindings.infer_nu: "config"
Options.Store -> Bindings.store_nu: "config"
Options.Obs -> Bindings.db_nu: "config"

# Nushell scripts → CLI (glue boundary)
Bindings.train_nu -> Drv.rl: "^rl train"
Bindings.eval_nu -> Drv.rl: "^rl eval"
Bindings.infer_nu -> Drv.rl: "^rl infer"
Bindings.db_nu -> Data.sqlite: "open | query db"

# CLI → Data (effects)
Drv.rl -> Data.sqlite: "write runs"
Drv.rl -> Data.logs: "stdout/stderr"
Drv.rl -> Data.models: "save checkpoints"

# Bindings → Instances (exports)
Bindings.train_nu -> Instances.cmds: "rl-train"
Bindings.eval_nu -> Instances.cmds: "rl-eval"
Bindings.infer_nu -> Instances.cmds: "rl-infer"
Bindings.db_nu -> Instances.cmds: "rl-db"
Bindings.store_nu -> Instances.devShell: "ENV vars"

# IDE panes → capabilities
IDE -> Instances.cmds: "shell pane"
IDE -> Data.logs: "logs pane"
IDE -> Data.sqlite: "db pane"
