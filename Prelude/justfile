# ===============================================================================
# UNIVERSES PRELUDE - Dendritic Nix Configuration System
# ===============================================================================
#
# NAME
#     justfile - Capability-centric module and machine management
#
# SYNOPSIS
#     just <recipe> [arguments...]
#     just --list
#
# DESCRIPTION
#     Thin interface to scripts in Modules/Computation/Scripts/.
#     Organized by capability, not implementation.
#
#     INTROSPECT  - Discover modules, features, and options
#     CREATE      - Scaffold new modules and features
#     BUILD       - Compile and validate
#     DEPLOY      - Flash and connect to machines
#     SYNC        - Remote build operations
#
# PHILOSOPHY
#     Index on CAPABILITY, not IMPLEMENTATION.
#     Options define types (what), Bindings define terms (how).
#     See AGENTS.md for full ontology.
#
# SCRIPTS
#     All scripts live in Modules/Computation/Scripts/Universe/*/Bindings/Scripts/
#
# ===============================================================================

scripts := "Modules/Computation/Scripts/Universe"

default:
    @just --list

# -------------------------------------------------------------------------------
# INTROSPECT
# -------------------------------------------------------------------------------

# List all modules by category (Computation, Information, Labs, Physical)
modules:
    @nu {{scripts}}/Discover/Bindings/Scripts/default.nu

# List Universe features in a module
# ARGS: module - path to module (e.g., Modules/Computation/Terminal/Shell)
features module:
    @echo '{"mode": "features", "module": "{{module}}"}' | nu {{scripts}}/Introspect/Bindings/Scripts/default.nu /dev/stdin

# Show Options type space for all features in a module
# ARGS: module - path to module (e.g., Modules/Computation/Terminal/Shell)
options module:
    @echo '{"mode": "options", "module": "{{module}}"}' | nu {{scripts}}/Introspect/Bindings/Scripts/default.nu /dev/stdin

# Show machine options schema (capability space for machine definitions)
schema:
    @echo "machines.<name> = {"
    @echo "  identity.hostname    : str           # What is this machine called?"
    @echo "  target.arch          : enum          # x86_64 | aarch64"
    @echo "  format.type          : enum          # iso | vm | sd-image | raw-efi"
    @echo "  persistence.strategy : enum          # full | impermanent | ephemeral"
    @echo "  persistence.device   : str?          # e.g., /dev/disk/by-label/NIXOS_PERSIST"
    @echo "  persistence.paths    : [str]         # Directories to persist"
    @echo "  users                : [user]        # Users on this machine"
    @echo "};"

# List all defined machines (queries flake.nixosConfigurations)
list:
    @nix eval .#nixosConfigurations --apply 'x: builtins.attrNames x' 2>/dev/null || echo "(eval error - run on Linux)"

# -------------------------------------------------------------------------------
# CREATE
# -------------------------------------------------------------------------------

# Scaffold a new module from frozen template (Docs/TEMPLATE.md)
# ARGS: path - module path (e.g., Modules/Computation/Foo)
new-module path:
    @echo '{"mode": "module", "path": "{{path}}"}' | nu {{scripts}}/Scaffold/Bindings/Scripts/default.nu /dev/stdin

# Add a feature to a module (creates Universe/<name> with Options/Bindings)
# ARGS: module - path to module, name - feature name (e.g., Core, Config)
new-feature module name:
    @echo '{"mode": "feature", "path": "{{module}}", "name": "{{name}}"}' | nu {{scripts}}/Scaffold/Bindings/Scripts/default.nu /dev/stdin

# -------------------------------------------------------------------------------
# BUILD
# -------------------------------------------------------------------------------

# Build a machine image based on its format.type option
# ARGS: machine - name of machine (e.g., sovereignty)
# NOTE: Must run on Linux to build NixOS images
build machine:
    nix build .#{{machine}}-iso --print-out-paths

# Run machine in QEMU VM for testing before flashing
# ARGS: machine - name of machine (e.g., sovereignty)
vm machine:
    nix run .#{{machine}}-vm

# Validate all modules (runs nix flake check)
check:
    nix flake check

# -------------------------------------------------------------------------------
# DEPLOY
# -------------------------------------------------------------------------------

# Flash ISO to USB drive (uses ~/Downloads/<machine>.iso if exists, else builds)
# ARGS: machine - name of machine, disk - target disk (e.g., /dev/disk4)
# WARNING: Erases all data on target disk
flash machine disk:
    @echo '{"mode": "flash", "machine": "{{machine}}", "disk": "{{disk}}"}' | nu {{scripts}}/Deploy/Bindings/Scripts/default.nu /dev/stdin

# Unmount all volumes on a disk (required before flashing)
# ARGS: disk - target disk (e.g., /dev/disk4)
unmount disk:
    @diskutil unmountDisk {{disk}} 2>/dev/null || echo "Already unmounted"

# Format SD card for persistence (ext4 with label NIXOS_PERSIST)
# ARGS: disk - target disk (e.g., /dev/sdb)
# WARNING: Erases all data on target disk
format-persist disk:
    @echo '{"mode": "format-persist", "disk": "{{disk}}"}' | nu {{scripts}}/Deploy/Bindings/Scripts/default.nu /dev/stdin

# SSH into a deployed machine
# ARGS: machine - hostname, user - SSH user (optional)
ssh machine user="":
    @if [ -z "{{user}}" ]; then ssh {{machine}}; else ssh {{user}}@{{machine}}; fi

# -------------------------------------------------------------------------------
# SYNC
# -------------------------------------------------------------------------------

# Sync repo to remote host (for building on Linux from macOS)
# ARGS: host - SSH host (e.g., cloud-dev)
sync-to host:
    rsync -avz --delete ~/repos/Universes/ {{host}}:~/repos/Universes/

# Build on remote host and copy ISO back to ~/Downloads/<machine>.iso
# ARGS: host - SSH host, machine - name of machine
remote-build host machine:
    @echo '{"mode": "remote-build", "host": "{{host}}", "machine": "{{machine}}"}' | nu {{scripts}}/Deploy/Bindings/Scripts/default.nu /dev/stdin
